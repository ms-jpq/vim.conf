\documentclass{beamer}
\usetheme{metropolis}
\usecolortheme{seahorse}
\setbeamertemplate{frame numbering}[fraction]
\metroset{block=fill}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\graphicspath{ {./imgs/} }

\usepackage{multicol}

\usepackage{soul} % strikethrough


\title{We Have Built Nice Things}
\subtitle{structured nvim plugins}
\author{Wang, Hao}
\institute{Lead Engineer @ Graveflex | ms-jpq @ github | hola@bigly.dog}
\date{}


\begin{document}


\begin{frame}

	% LaTex tutorial
	% https://www.youtube.com/watch?v=0fsWGg81RwU

	\titlepage

\end{frame}


\begin{frame}{Inspiration}

	We can have nice things - \textit{Justin M. Keyes}

	\vspace{1em}

	\includegraphics[width=\textwidth]{we_can_have_nice}

\end{frame}


\begin{frame}{Why Nvim?}

	I wanted to replace emacs

	\vspace{1em}

	\includegraphics[width=\textwidth]{home_page}

	\vspace{1em}

	...and make CLI as easy as VSCode

\end{frame}


\begin{frame}{Vim "philosophy"}

	\begin{itemize}

		\begin{multicols}{2}

			\item unix-y

			\item ad hoc

			\item macro driven

			\item minimalist

			\item extensible

			\item composible

			\item conservative

		\end{multicols}

	\end{itemize}

	\rule{\textwidth}{0.1em}

	\textbf{But at what cost?}

	\begin{itemize}

		\begin{multicols}{2}

			\item slowiness

			\item jankiness

			\item ossification

			\item interlocking

			\item beginner hostile

			\item dx hostile

		\end{multicols}

	\end{itemize}


\end{frame}


\begin{frame}{Terraforming Nvim}
	
	\begin{block}{Terraforming}

		\vspace{0.5em}

		Making nvim more hospitable for developers

		\vspace{0.5em}

	\end{block}

	\rule{\textwidth}{0.1em}

	\begin{itemize}

		\begin{multicols}{2}

			\item lua
			
			\item vim.api.nvim\_*

			\item API clients

			\item tree-sitter

			\item libuv

			\item extmarks

			\item virtual text

			\item remote UI

		\end{multicols}

	\end{itemize}

	... and more 

\end{frame}


\begin{frame}{Tolerance for Heresy}

	Beyond just the API, but also the \textbf{culture too}

	\rule{\textwidth}{0.1em}

	\textbf{Wait, you can do that??}

	\begin{enumerate}

		\item nvim = OS for TUI

		\item buffers = render targets

		\item architecture <- react + redux, data driven

		\item "AOT compiled, statically linked"

		\item Well defined protocols

	\end{enumerate}

\end{frame}


\begin{frame}{Yes We Can}

	Short detour

	\rule{\textwidth}{0.1em}

	Lua is awesome

	You can write \textit{async await} as a \textbf{library}, (first class coroutines)

	https://github.com/ms-jpq/lua-async-await

\end{frame}

% \begin{frame}{What Programmers Like}

% 	\textbf{Structure \& Regularity}

% 	\includegraphics[width=\textwidth]{rice_paddy}

% 	\textit{thousand year old rice paddy}

% \end{frame}


\begin{frame}{AOT Static Linking}

	\begin{block}{\st{Extensibility} Kitchen sink}

		\vspace{0.5em}

		Do one \st{thing} \textbf{domain} and do it well.

		\vspace{0.5em}

	\end{block}

	Bake related features into single plugin

	\rule{\textwidth}{0.1em}

	Still "composible"

	\begin{itemize}

		\item pre-compile third party themes into json

		\item pre-compile third party snippets into json

		\item pre-compile ... into json

	\end{itemize}

\end{frame}


\begin{frame}{CHADTree}

	https://github.com/ms-jpq/chadtree

	\rule{\textwidth}{0.1em}

	\begin{itemize}

		\begin{multicols}{2}
  	
			\item visual multi selection

			\item persistent selection across copy / move

			\item quickfix highlight

			\item glob filtering

			\item trash bin

			\item open with sys

			\item ls -l

			\item follow mode

			\item version control status

			\item \$LS\_COLOUR theming

			\item icons out of box

			\item github derived language colouring

			\item session support

			\item typed config parser
  	
		\end{multicols}

	\end{itemize}

\end{frame}


\begin{frame}{Faster than LUA}

	\begin{block}{Observations}

		\begin{enumerate}

			\item File system walking is very fast

			\item Rendering is slow

			\item Filemanager plugins cause dramatic slowdowns

		\end{enumerate}

	\end{block}

	\begin{block}{Solution}

		\begin{itemize}

			\item Pull in plugin functionalities

			\item Minimize rendering

		\end{itemize}
 	
	\end{block}

	Big tradeoff: lose extensibility

	Big win: no ossification

\end{frame}


\begin{frame}{React Redux}

	I wrote a \textit{70 line} React before, it's not hard:

	https://github.com/ms-jpq/noact

	\rule{\textwidth}{0.1em}

	Virtual rendering target (store desired state)

	\begin{enumerate}

		\item Compute designed state

		\item Compute linewise hash of desired state

	\end{enumerate}

	Actual rendering target (apply state to buffers)

	\begin{enumerate}

		\item Fetch hash -> compute minimal diff

		\item Apply patch onto buffers, store hash

	\end{enumerate}

\end{frame}


\begin{frame}{COQ.nvim}

	Fast AF auto completion, backed by \textit{SQLite}

	https://github.com/ms-jpq/coq\_nvim
	
	\begin{block}{Observations}

		\begin{itemize}

			\item Computers are \textit{fast}, humans are \textit{slow}

			\item Typos happen frequently

			\item Completion menu is ad hoc doc viewer

			\item \textbf{Has to be extensible}

		\end{itemize}
 	
	\end{block}

	\rule{\textwidth}{0.1em}

	Can't just AOT everything

\end{frame}


\begin{frame}{Ossification Kills}

	Need to support third party plugins, but...

	Notice a pattern here:

	\begin{itemize}

		\item nvim-completion-manager -> ncm2

		\item neocomplete.vim -> deoplete.nvim -> ddc.vim

		\item nvim-compe -> nvim-cmp

		\item completion-nvim :: still ok!

	\end{itemize}

	Too big to rewrite:

	\begin{itemize}

		\item YouCompleteMe

		\item coc.nvim

	\end{itemize}

\end{frame}


\begin{frame}{The Protocols of Nvim}

	Protocols are \textbf{meant to be ossified}

	Implementations are not

	\rule{\textwidth}{0.1em}

	Some protocols inherent to Nvim

	\begin{itemize}

		\item vim.bo.omnifunc

		\item :h complete-items

		\item \textbf{LSP}

	\end{itemize}

\end{frame}


\begin{frame}{Social Distancing}

	Third party / lua sources \textbf{CAN NOT} call into coq.nvim

	They register callbacks at well known locations

	They communicate via existing protocols

	\rule{\textwidth}{0.1em}

	https://github.com/ms-jpq/coq.thirdparty

\end{frame}


\begin{frame}{Data Driven}
	
	Humans need to read completions

	Optimization problem between \textbf{quality} \& \textbf{speed}

	\rule{\textwidth}{0.1em}

	\begin{multicols}{2}
 	
		\textbf{Filtering}
  	
		Lowerbound on intersection size between multisets of text

		\columnbreak
		
		\textbf{Ensemble Ranking}
  	
		Damerauâ€“Levenshtein distance

		Insertion recency

		Text locality

		...

	\end{multicols}

	Adjust both for lookahead

\end{frame}


\begin{frame}{Scheduler}
	
	\begin{itemize}

		\item Concurrency is not parallelism

		\item Trade \textit{throughput} for \textit{latency}

		\item Ubiquitous coroutine based lazy computation

		\item Cancel culture

		\item Flow control

		\item Background caching

		\item Soft deadlines

	\end{itemize}

\end{frame}


\begin{frame}{Still AOT}
	
	The most completion sources out of the box

	\begin{itemize}

		\item LSP - multi-server, clientside caching, snippet support

		\item Snippets - over 13000 built-in, live repl, custom snips

		\item Treesitter - partial parsing, disable disable if slow, LSP like context

		\item CTags - LSP like metadata, background compilation, sqlite instead of nvim's blocking built-in

		\item Paths - previews contents, variable expansion

		\item Buffers - real time

		\item Tmux

		\item Tabnine - auto download

	\end{itemize}

\end{frame}


\begin{frame}{Even More LUA Sources}

	\begin{itemize}

		\item Shell REPL

		\item Nvim LUA API

		\item Scientific calculator
		
		\item Commented banner

	\end{itemize}

\end{frame}


\begin{frame}{Benchmarks}

	https://github.com/ms-jpq/vim.bench

	\rule{\textwidth}{0.1em}

	Reproducible Docker based tmux typist

	Kernel density estimates

\end{frame}


\begin{frame}[standout]

	Q \& A

\end{frame}


\end{document}
