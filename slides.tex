\documentclass{beamer}
\usetheme{metropolis}
\usecolortheme{seahorse}
\setbeamertemplate{frame numbering}[fraction]
\metroset{block=fill}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\graphicspath{ {./imgs/} }

\usepackage{multicol}

\usepackage{soul} % strikethrough


\title{We Have Built Nice Things}
\subtitle{Structured Nvim Plugins}
\author{Wang, Hao}
\institute{Lead Engineer @ Graveflex | ms-jpq @ github | hola@bigly.dog}
\date{}


\begin{document}


\begin{frame}

	% LaTex tutorial
	% https://www.youtube.com/watch?v=0fsWGg81RwU

	\titlepage

\end{frame}


\begin{frame}{Correction}

	Wrong employer on speakers list

	\rule{\textwidth}{0.1em}

	Worked for \textit{SunCloud} not \textit{SoundCloud}

	\hspace{0.1em}

	Now works at \textbf{Graveflex}

\end{frame}


\begin{frame}{Inspiration}

	We can have nice things - \textit{Justin M. Keyes}

	\vspace{1em}

	\includegraphics[width=\textwidth]{we_can_have_nice}

\end{frame}


\begin{frame}{Why Nvim?}

	I wanted to replace emacs

	\vspace{1em}

	\includegraphics[width=\textwidth]{home_page}

	\vspace{1em}

\end{frame}


\begin{frame}{Talk}

	Plugin author's prespective on Nvim innovations

	\rule{\textwidth}{0.1em}

	\begin{itemize}

		\item CHADTree

		      File manager

		      \hspace{0.1em}

		\item COQ.nvim

		      Auto completion

	\end{itemize}

	\rule{\textwidth}{0.1em}

	I want to make CLI as easy as VSCode

\end{frame}


\begin{frame}{What Programmers Like}

	\textbf{Structure \& Regularity}

	\includegraphics[width=\textwidth]{rice_paddy}

	\textit{thousand year old rice paddy}

\end{frame}


\begin{frame}{Terraforming Nvim}

	\begin{block}{Terraforming}

		\vspace{0.5em}

		Making nvim more hospitable for developers

		\vspace{0.5em}

	\end{block}

	\rule{\textwidth}{0.1em}

	\begin{itemize}

		\begin{multicols}{2}

			\item lua

			\item vim.api.nvim\_*

			\item API clients

			\item tree-sitter

			\item libuv

			\item extmarks

			\item virtual text

			\item remote UI

		\end{multicols}

	\end{itemize}

	... and more

\end{frame}


\begin{frame}{Yes We Can}

	Short detour

	\rule{\textwidth}{0.1em}

	Lua is powerful

	You can write \textit{async await} as a \textbf{library}, (first class coroutines)

	https://github.com/ms-jpq/lua-async-await

	\hspace{0.1em}

	\textit{(Like Clojure core.async)}

\end{frame}


\begin{frame}{Vim "philosophy"}

	\begin{itemize}

		\begin{multicols}{2}

			\item unix-y

			\item ad hoc

			\item macro driven

			\item minimalist

			\item extensible

			\item composible

			\item conservative

		\end{multicols}

	\end{itemize}

\end{frame}


\begin{frame}{Weight of History}

	\begin{itemize}

		\begin{multicols}{2}

			\item slowiness

			\item jankiness

			\item ossification

			\item interlocking

			\item beginner hostile

			\item dx hostile

		\end{multicols}

	\end{itemize}

\end{frame}


\begin{frame}{Tolerance for Heresy}

	Beyond just the API, but also the \textbf{culture too}

	\rule{\textwidth}{0.1em}

	\textbf{Wait, you can do that??}

	\begin{enumerate}

		\item nvim = Browser for TUI

		\item buffers = render targets

		\item architecture <- systematic, data driven

		\item "AOT compiled, statically linked"

		\item Well defined protocols

	\end{enumerate}

\end{frame}


\begin{frame}{\textit{Browser} for the TUI}

	\textbf{Nvim wants to be a platform}

	\rule{\textwidth}{0.1em}

	\hspace{0.1em}

	\begin{block}{Official API Clients}

		\begin{itemize}

			\begin{multicols}{2}

				\item c\#

				\item go

				\item node

				\item python

				\item ruby

			\end{multicols}

		\end{itemize}

	\end{block}

	And tons and tons of unofficial ones..

\end{frame}


\begin{frame}{We Are Not There Yet}

	Lots of UIs, not many client-server plugins

	\rule{\textwidth}{0.1em}

	Need more than a faster horse

	\hspace{0.1em}

	Have to be \textbf{\textit{significantly better}}

\end{frame}


\begin{frame}{AOT Static Linking}

	\begin{block}{\st{Extensibility} Kitchen sink}

		\vspace{0.5em}

		Do one \st{thing} \textbf{domain} and do it well.

		\vspace{0.5em}

	\end{block}

	\hspace{0.1em}

	Dual Approach:

	\begin{enumerate}

		\item Scrapping

		\item Write it yourself (but do it good)

	\end{enumerate}

\end{frame}


\begin{frame}{Ossification \textit{Good?}}

	"Zero runtime cost" -- \st{rust} JSON

	\begin{enumerate}

		\item Compile \text{existing plugins} for artifacts

		\item Dump them into a static file

	\end{enumerate}

	\rule{\textwidth}{0.1em}

	\begin{itemize}

		\item CHADTree

		      \begin{itemize}

			      \item 3 icon themes

			      \item 9 colour themes

			      \item 700+ language colours

		      \end{itemize}

		\item COQ.nvim

		      \begin{itemize}

			      \item 13,000+ snippets

			      \item \textbf{zero runtime parse errors}

		      \end{itemize}

	\end{itemize}

\end{frame}


\begin{frame}{Faster than LUA}

	\begin{block}{Observations}

		\begin{enumerate}

			\item File system walking is very fast

			\item Rendering is slow

			\item Filemanager plugins cause dramatic slowdowns

		\end{enumerate}

	\end{block}

	\begin{block}{Solution}

		\begin{itemize}

			\item Pull in plugin functionalities

			\item Minimize rendering

		\end{itemize}

	\end{block}

	Big tradeoff: lose extensibility

	Big win: no ossification

\end{frame}


\begin{frame}{CHADTree}

	https://github.com/ms-jpq/chadtree

	\rule{\textwidth}{0.1em}

	\begin{itemize}

		\begin{multicols}{2}

			\item visual multi selection

			\item persistent selection across copy / move

			\item quickfix highlight

			\item glob filtering

			\item trash bin

			\item open with sys

			\item ls -l

			\item follow mode

			\item version control status

			\item \$LS\_COLOUR theming

			\item icons out of box

			\item github derived language colouring

			\item session support

			\item typed config parser

		\end{multicols}

	\end{itemize}

\end{frame}


\begin{frame}{React Redux}

	I wrote a \textit{70 line} React before, it's not hard:

	https://github.com/ms-jpq/noact

	\rule{\textwidth}{0.1em}

	Virtual rendering target (store desired state)

	\begin{enumerate}

		\item Compute designed state

		\item Compute linewise hash of desired state

	\end{enumerate}

	Actual rendering target (apply state to buffers)

	\begin{enumerate}

		\item Fetch hash -> compute minimal diff

		\item Apply patch onto buffers, store hash

	\end{enumerate}

\end{frame}


\begin{frame}{COQ.nvim}

	Fast AF auto completion, backed by \textit{SQLite}

	https://github.com/ms-jpq/coq\_nvim

	\begin{block}{Observations}

		\begin{itemize}

			\item Computers are \textit{fast}, humans are \textit{slow}

			\item Typos happen frequently

			\item Completion menu is ad hoc doc viewer

			\item \textbf{Has to be extensible}

		\end{itemize}

	\end{block}

	\rule{\textwidth}{0.1em}

	Can't just AOT everything

\end{frame}


\begin{frame}{Ossification Kills}

	Need to support third party plugins, but...

	Notice a pattern here:

	\begin{itemize}

		\item nvim-completion-manager -> ncm2

		\item neocomplete.vim -> deoplete.nvim -> ddc.vim

		\item nvim-compe -> nvim-cmp

		\item completion-nvim -> \st{still ok!} \textit{archived}

	\end{itemize}

	Too big to rewrite:

	\begin{itemize}

		\item YouCompleteMe

		\item coc.nvim

	\end{itemize}

\end{frame}


\begin{frame}{The Protocols of Nvim}

	Protocols are \textbf{meant to be ossified}

	Implementations are not

	\rule{\textwidth}{0.1em}

	Some protocols inherent to Nvim

	\begin{itemize}

		\item vim.bo.omnifunc

		\item :h complete-items

		\item \textbf{LSP}

	\end{itemize}

\end{frame}


\begin{frame}{Social Distancing}

	Third party / lua sources \textbf{CAN NOT} call into coq.nvim

	They register callbacks at well known locations

	They communicate via existing protocols

	\rule{\textwidth}{0.1em}

	https://github.com/ms-jpq/coq.thirdparty

\end{frame}


\begin{frame}{Data Driven}

	Humans need to read completions

	Optimization problem between \textbf{quality} \& \textbf{speed}

	\rule{\textwidth}{0.1em}

	\begin{multicols}{2}

		\textbf{Filtering}

		Lowerbound on intersection size between multisets of text

		\columnbreak

		\textbf{Ensemble Ranking}

		Damerauâ€“Levenshtein distance

		Insertion recency

		Text locality

		...

	\end{multicols}

	Adjust both for lookahead

\end{frame}


\begin{frame}{Scheduler}

	\begin{itemize}

		\item Concurrency is not parallelism

		\item Trade \textit{throughput} for \textit{latency}

		\item Ubiquitous coroutine based lazy computation

		\item Cancel culture

		\item Flow control

		\item Background caching

		\item Soft deadlines

	\end{itemize}

\end{frame}


\begin{frame}{Still AOT}

	The most completion sources out of the box

	\begin{itemize}

		\item LSP - multi-server, clientside caching, snippet support

		\item Snippets - over 13000 built-in, live repl, custom snips

		\item Treesitter - partial parsing, disable disable if slow, LSP like context

		\item CTags - LSP like metadata, background compilation, sqlite instead of nvim's blocking built-in

		\item Paths - previews contents, variable expansion

		\item Buffers - real time

		\item Tmux

		\item Tabnine - auto download

	\end{itemize}

\end{frame}


\begin{frame}{Even More LUA Sources}

	\begin{itemize}

		\item Shell REPL

		\item Nvim LUA API

		\item Scientific calculator

		\item Commented banner

	\end{itemize}

\end{frame}


\begin{frame}{Benchmarks}

	https://github.com/ms-jpq/vim.bench

	\rule{\textwidth}{0.1em}

	Reproducible Docker based tmux typist

	Kernel density estimates

\end{frame}


\begin{frame}{Tying the Knot}

	\begin{centering}

		{\Large Technical Innovation $\cup$ Cultural Innovation}

		\rule{\textwidth}{0.1em}

		{\LARGE Nice things}

	\end{centering}

\end{frame}


\begin{frame}[standout]

	Q \& A

\end{frame}


\end{document}
